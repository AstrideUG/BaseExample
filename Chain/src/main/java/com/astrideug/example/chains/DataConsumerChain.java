package com.astrideug.example.chains;

import com.astrideug.base.chain.annotations.ChainId;
import com.astrideug.base.chain.type.Validateable;
import com.astrideug.base.chain.type.impl.KeyNotEqualsValidator;
import com.astrideug.example.Data;
import me.helight.ccom.collections.Pair;
import me.helight.ccom.collections.Tuple;
import me.helight.ccom.concurrency.Chain;
import me.helight.ccom.concurrency.Environment;
import me.helight.ccom.concurrency.chain.EnvAdrr;

import java.util.List;

@ChainId("consume")
public class DataConsumerChain extends Chain {

    //Cancels execution of chain, if the data generated by the Supply Chain is equal to DATA_1
    private Validateable noData1 = new KeyNotEqualsValidator(EnvAdrr.from("supply"), Data.DATA_1);

    //Cancels execution of chain, if the data generated by the Supply Chain is equal to DATA_2
    private Validateable noData2 = new KeyNotEqualsValidator(EnvAdrr.from("supply"), Data.DATA_2);

    public DataConsumerChain() {
        consume(t -> {
            Pair<Integer, Environment> pair = Tuple.pair((List)t, Integer.class, Environment.class);
            System.out.println("Thread " + pair.getA() + "finished with Data3 env: " + pair.getB());
        }).adresses(EnvAdrr.from("threadID"), EnvAdrr.from("env"));
    }
}
